// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package api

import (
	context "context"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// CirrusConfigurationEvaluatorServiceClient is the client API for CirrusConfigurationEvaluatorService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CirrusConfigurationEvaluatorServiceClient interface {
	EvaluateConfig(ctx context.Context, in *EvaluateConfigRequest, opts ...grpc.CallOption) (*EvaluateConfigResponse, error)
}

type cirrusConfigurationEvaluatorServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCirrusConfigurationEvaluatorServiceClient(cc grpc.ClientConnInterface) CirrusConfigurationEvaluatorServiceClient {
	return &cirrusConfigurationEvaluatorServiceClient{cc}
}

var cirrusConfigurationEvaluatorServiceEvaluateConfigStreamDesc = &grpc.StreamDesc{
	StreamName: "EvaluateConfig",
}

func (c *cirrusConfigurationEvaluatorServiceClient) EvaluateConfig(ctx context.Context, in *EvaluateConfigRequest, opts ...grpc.CallOption) (*EvaluateConfigResponse, error) {
	out := new(EvaluateConfigResponse)
	err := c.cc.Invoke(ctx, "/org.cirruslabs.ci.services.cirruscigrpc.CirrusConfigurationEvaluatorService/EvaluateConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CirrusConfigurationEvaluatorServiceService is the service API for CirrusConfigurationEvaluatorService service.
// Fields should be assigned to their respective handler implementations only before
// RegisterCirrusConfigurationEvaluatorServiceService is called.  Any unassigned fields will result in the
// handler for that method returning an Unimplemented error.
type CirrusConfigurationEvaluatorServiceService struct {
	EvaluateConfig func(context.Context, *EvaluateConfigRequest) (*EvaluateConfigResponse, error)
}

func (s *CirrusConfigurationEvaluatorServiceService) evaluateConfig(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvaluateConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.EvaluateConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/org.cirruslabs.ci.services.cirruscigrpc.CirrusConfigurationEvaluatorService/EvaluateConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.EvaluateConfig(ctx, req.(*EvaluateConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RegisterCirrusConfigurationEvaluatorServiceService registers a service implementation with a gRPC server.
func RegisterCirrusConfigurationEvaluatorServiceService(s grpc.ServiceRegistrar, srv *CirrusConfigurationEvaluatorServiceService) {
	srvCopy := *srv
	if srvCopy.EvaluateConfig == nil {
		srvCopy.EvaluateConfig = func(context.Context, *EvaluateConfigRequest) (*EvaluateConfigResponse, error) {
			return nil, status.Errorf(codes.Unimplemented, "method EvaluateConfig not implemented")
		}
	}
	sd := grpc.ServiceDesc{
		ServiceName: "org.cirruslabs.ci.services.cirruscigrpc.CirrusConfigurationEvaluatorService",
		Methods: []grpc.MethodDesc{
			{
				MethodName: "EvaluateConfig",
				Handler:    srvCopy.evaluateConfig,
			},
		},
		Streams:  []grpc.StreamDesc{},
		Metadata: "cirrus_ci_service.proto",
	}

	s.RegisterService(&sd, nil)
}

// CirrusCIServiceClient is the client API for CirrusCIService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CirrusCIServiceClient interface {
	InitialCommands(ctx context.Context, in *InitialCommandsRequest, opts ...grpc.CallOption) (*CommandsResponse, error)
	ReportSingleCommand(ctx context.Context, in *ReportSingleCommandRequest, opts ...grpc.CallOption) (*ReportSingleCommandResponse, error)
	ReportAnnotations(ctx context.Context, in *ReportAnnotationsCommandRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	StreamLogs(ctx context.Context, opts ...grpc.CallOption) (CirrusCIService_StreamLogsClient, error)
	SaveLogs(ctx context.Context, opts ...grpc.CallOption) (CirrusCIService_SaveLogsClient, error)
	UploadCache(ctx context.Context, opts ...grpc.CallOption) (CirrusCIService_UploadCacheClient, error)
	UploadArtifacts(ctx context.Context, opts ...grpc.CallOption) (CirrusCIService_UploadArtifactsClient, error)
	DownloadCache(ctx context.Context, in *DownloadCacheRequest, opts ...grpc.CallOption) (CirrusCIService_DownloadCacheClient, error)
	CacheInfo(ctx context.Context, in *CacheInfoRequest, opts ...grpc.CallOption) (*CacheInfoResponse, error)
	Ping(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	Heartbeat(ctx context.Context, in *HeartbeatRequest, opts ...grpc.CallOption) (*HeartbeatResponse, error)
	ReportStopHook(ctx context.Context, in *ReportStopHookRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	ReportAgentError(ctx context.Context, in *ReportAgentProblemRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	ReportAgentWarning(ctx context.Context, in *ReportAgentProblemRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	ReportAgentSignal(ctx context.Context, in *ReportAgentSignalRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	ReportAgentLogs(ctx context.Context, in *ReportAgentLogsRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	ParseConfig(ctx context.Context, in *ParseConfigRequest, opts ...grpc.CallOption) (*ParseConfigResponse, error)
}

type cirrusCIServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCirrusCIServiceClient(cc grpc.ClientConnInterface) CirrusCIServiceClient {
	return &cirrusCIServiceClient{cc}
}

var cirrusCIServiceInitialCommandsStreamDesc = &grpc.StreamDesc{
	StreamName: "InitialCommands",
}

func (c *cirrusCIServiceClient) InitialCommands(ctx context.Context, in *InitialCommandsRequest, opts ...grpc.CallOption) (*CommandsResponse, error) {
	out := new(CommandsResponse)
	err := c.cc.Invoke(ctx, "/org.cirruslabs.ci.services.cirruscigrpc.CirrusCIService/InitialCommands", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var cirrusCIServiceReportSingleCommandStreamDesc = &grpc.StreamDesc{
	StreamName: "ReportSingleCommand",
}

func (c *cirrusCIServiceClient) ReportSingleCommand(ctx context.Context, in *ReportSingleCommandRequest, opts ...grpc.CallOption) (*ReportSingleCommandResponse, error) {
	out := new(ReportSingleCommandResponse)
	err := c.cc.Invoke(ctx, "/org.cirruslabs.ci.services.cirruscigrpc.CirrusCIService/ReportSingleCommand", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var cirrusCIServiceReportAnnotationsStreamDesc = &grpc.StreamDesc{
	StreamName: "ReportAnnotations",
}

func (c *cirrusCIServiceClient) ReportAnnotations(ctx context.Context, in *ReportAnnotationsCommandRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/org.cirruslabs.ci.services.cirruscigrpc.CirrusCIService/ReportAnnotations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var cirrusCIServiceStreamLogsStreamDesc = &grpc.StreamDesc{
	StreamName:    "StreamLogs",
	ClientStreams: true,
}

func (c *cirrusCIServiceClient) StreamLogs(ctx context.Context, opts ...grpc.CallOption) (CirrusCIService_StreamLogsClient, error) {
	stream, err := c.cc.NewStream(ctx, cirrusCIServiceStreamLogsStreamDesc, "/org.cirruslabs.ci.services.cirruscigrpc.CirrusCIService/StreamLogs", opts...)
	if err != nil {
		return nil, err
	}
	x := &cirrusCIServiceStreamLogsClient{stream}
	return x, nil
}

type CirrusCIService_StreamLogsClient interface {
	Send(*LogEntry) error
	CloseAndRecv() (*UploadLogsResponse, error)
	grpc.ClientStream
}

type cirrusCIServiceStreamLogsClient struct {
	grpc.ClientStream
}

func (x *cirrusCIServiceStreamLogsClient) Send(m *LogEntry) error {
	return x.ClientStream.SendMsg(m)
}

func (x *cirrusCIServiceStreamLogsClient) CloseAndRecv() (*UploadLogsResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(UploadLogsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var cirrusCIServiceSaveLogsStreamDesc = &grpc.StreamDesc{
	StreamName:    "SaveLogs",
	ClientStreams: true,
}

func (c *cirrusCIServiceClient) SaveLogs(ctx context.Context, opts ...grpc.CallOption) (CirrusCIService_SaveLogsClient, error) {
	stream, err := c.cc.NewStream(ctx, cirrusCIServiceSaveLogsStreamDesc, "/org.cirruslabs.ci.services.cirruscigrpc.CirrusCIService/SaveLogs", opts...)
	if err != nil {
		return nil, err
	}
	x := &cirrusCIServiceSaveLogsClient{stream}
	return x, nil
}

type CirrusCIService_SaveLogsClient interface {
	Send(*LogEntry) error
	CloseAndRecv() (*UploadLogsResponse, error)
	grpc.ClientStream
}

type cirrusCIServiceSaveLogsClient struct {
	grpc.ClientStream
}

func (x *cirrusCIServiceSaveLogsClient) Send(m *LogEntry) error {
	return x.ClientStream.SendMsg(m)
}

func (x *cirrusCIServiceSaveLogsClient) CloseAndRecv() (*UploadLogsResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(UploadLogsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var cirrusCIServiceUploadCacheStreamDesc = &grpc.StreamDesc{
	StreamName:    "UploadCache",
	ClientStreams: true,
}

func (c *cirrusCIServiceClient) UploadCache(ctx context.Context, opts ...grpc.CallOption) (CirrusCIService_UploadCacheClient, error) {
	stream, err := c.cc.NewStream(ctx, cirrusCIServiceUploadCacheStreamDesc, "/org.cirruslabs.ci.services.cirruscigrpc.CirrusCIService/UploadCache", opts...)
	if err != nil {
		return nil, err
	}
	x := &cirrusCIServiceUploadCacheClient{stream}
	return x, nil
}

type CirrusCIService_UploadCacheClient interface {
	Send(*CacheEntry) error
	CloseAndRecv() (*UploadCacheResponse, error)
	grpc.ClientStream
}

type cirrusCIServiceUploadCacheClient struct {
	grpc.ClientStream
}

func (x *cirrusCIServiceUploadCacheClient) Send(m *CacheEntry) error {
	return x.ClientStream.SendMsg(m)
}

func (x *cirrusCIServiceUploadCacheClient) CloseAndRecv() (*UploadCacheResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(UploadCacheResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var cirrusCIServiceUploadArtifactsStreamDesc = &grpc.StreamDesc{
	StreamName:    "UploadArtifacts",
	ClientStreams: true,
}

func (c *cirrusCIServiceClient) UploadArtifacts(ctx context.Context, opts ...grpc.CallOption) (CirrusCIService_UploadArtifactsClient, error) {
	stream, err := c.cc.NewStream(ctx, cirrusCIServiceUploadArtifactsStreamDesc, "/org.cirruslabs.ci.services.cirruscigrpc.CirrusCIService/UploadArtifacts", opts...)
	if err != nil {
		return nil, err
	}
	x := &cirrusCIServiceUploadArtifactsClient{stream}
	return x, nil
}

type CirrusCIService_UploadArtifactsClient interface {
	Send(*ArtifactEntry) error
	CloseAndRecv() (*UploadArtifactsResponse, error)
	grpc.ClientStream
}

type cirrusCIServiceUploadArtifactsClient struct {
	grpc.ClientStream
}

func (x *cirrusCIServiceUploadArtifactsClient) Send(m *ArtifactEntry) error {
	return x.ClientStream.SendMsg(m)
}

func (x *cirrusCIServiceUploadArtifactsClient) CloseAndRecv() (*UploadArtifactsResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(UploadArtifactsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var cirrusCIServiceDownloadCacheStreamDesc = &grpc.StreamDesc{
	StreamName:    "DownloadCache",
	ServerStreams: true,
}

func (c *cirrusCIServiceClient) DownloadCache(ctx context.Context, in *DownloadCacheRequest, opts ...grpc.CallOption) (CirrusCIService_DownloadCacheClient, error) {
	stream, err := c.cc.NewStream(ctx, cirrusCIServiceDownloadCacheStreamDesc, "/org.cirruslabs.ci.services.cirruscigrpc.CirrusCIService/DownloadCache", opts...)
	if err != nil {
		return nil, err
	}
	x := &cirrusCIServiceDownloadCacheClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CirrusCIService_DownloadCacheClient interface {
	Recv() (*DataChunk, error)
	grpc.ClientStream
}

type cirrusCIServiceDownloadCacheClient struct {
	grpc.ClientStream
}

func (x *cirrusCIServiceDownloadCacheClient) Recv() (*DataChunk, error) {
	m := new(DataChunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var cirrusCIServiceCacheInfoStreamDesc = &grpc.StreamDesc{
	StreamName: "CacheInfo",
}

func (c *cirrusCIServiceClient) CacheInfo(ctx context.Context, in *CacheInfoRequest, opts ...grpc.CallOption) (*CacheInfoResponse, error) {
	out := new(CacheInfoResponse)
	err := c.cc.Invoke(ctx, "/org.cirruslabs.ci.services.cirruscigrpc.CirrusCIService/CacheInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var cirrusCIServicePingStreamDesc = &grpc.StreamDesc{
	StreamName: "Ping",
}

func (c *cirrusCIServiceClient) Ping(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/org.cirruslabs.ci.services.cirruscigrpc.CirrusCIService/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var cirrusCIServiceHeartbeatStreamDesc = &grpc.StreamDesc{
	StreamName: "Heartbeat",
}

func (c *cirrusCIServiceClient) Heartbeat(ctx context.Context, in *HeartbeatRequest, opts ...grpc.CallOption) (*HeartbeatResponse, error) {
	out := new(HeartbeatResponse)
	err := c.cc.Invoke(ctx, "/org.cirruslabs.ci.services.cirruscigrpc.CirrusCIService/Heartbeat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var cirrusCIServiceReportStopHookStreamDesc = &grpc.StreamDesc{
	StreamName: "ReportStopHook",
}

func (c *cirrusCIServiceClient) ReportStopHook(ctx context.Context, in *ReportStopHookRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/org.cirruslabs.ci.services.cirruscigrpc.CirrusCIService/ReportStopHook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var cirrusCIServiceReportAgentErrorStreamDesc = &grpc.StreamDesc{
	StreamName: "ReportAgentError",
}

func (c *cirrusCIServiceClient) ReportAgentError(ctx context.Context, in *ReportAgentProblemRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/org.cirruslabs.ci.services.cirruscigrpc.CirrusCIService/ReportAgentError", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var cirrusCIServiceReportAgentWarningStreamDesc = &grpc.StreamDesc{
	StreamName: "ReportAgentWarning",
}

func (c *cirrusCIServiceClient) ReportAgentWarning(ctx context.Context, in *ReportAgentProblemRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/org.cirruslabs.ci.services.cirruscigrpc.CirrusCIService/ReportAgentWarning", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var cirrusCIServiceReportAgentSignalStreamDesc = &grpc.StreamDesc{
	StreamName: "ReportAgentSignal",
}

func (c *cirrusCIServiceClient) ReportAgentSignal(ctx context.Context, in *ReportAgentSignalRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/org.cirruslabs.ci.services.cirruscigrpc.CirrusCIService/ReportAgentSignal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var cirrusCIServiceReportAgentLogsStreamDesc = &grpc.StreamDesc{
	StreamName: "ReportAgentLogs",
}

func (c *cirrusCIServiceClient) ReportAgentLogs(ctx context.Context, in *ReportAgentLogsRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/org.cirruslabs.ci.services.cirruscigrpc.CirrusCIService/ReportAgentLogs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var cirrusCIServiceParseConfigStreamDesc = &grpc.StreamDesc{
	StreamName: "ParseConfig",
}

func (c *cirrusCIServiceClient) ParseConfig(ctx context.Context, in *ParseConfigRequest, opts ...grpc.CallOption) (*ParseConfigResponse, error) {
	out := new(ParseConfigResponse)
	err := c.cc.Invoke(ctx, "/org.cirruslabs.ci.services.cirruscigrpc.CirrusCIService/ParseConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CirrusCIServiceService is the service API for CirrusCIService service.
// Fields should be assigned to their respective handler implementations only before
// RegisterCirrusCIServiceService is called.  Any unassigned fields will result in the
// handler for that method returning an Unimplemented error.
type CirrusCIServiceService struct {
	InitialCommands     func(context.Context, *InitialCommandsRequest) (*CommandsResponse, error)
	ReportSingleCommand func(context.Context, *ReportSingleCommandRequest) (*ReportSingleCommandResponse, error)
	ReportAnnotations   func(context.Context, *ReportAnnotationsCommandRequest) (*empty.Empty, error)
	StreamLogs          func(CirrusCIService_StreamLogsServer) error
	SaveLogs            func(CirrusCIService_SaveLogsServer) error
	UploadCache         func(CirrusCIService_UploadCacheServer) error
	UploadArtifacts     func(CirrusCIService_UploadArtifactsServer) error
	DownloadCache       func(*DownloadCacheRequest, CirrusCIService_DownloadCacheServer) error
	CacheInfo           func(context.Context, *CacheInfoRequest) (*CacheInfoResponse, error)
	Ping                func(context.Context, *empty.Empty) (*empty.Empty, error)
	Heartbeat           func(context.Context, *HeartbeatRequest) (*HeartbeatResponse, error)
	ReportStopHook      func(context.Context, *ReportStopHookRequest) (*empty.Empty, error)
	ReportAgentError    func(context.Context, *ReportAgentProblemRequest) (*empty.Empty, error)
	ReportAgentWarning  func(context.Context, *ReportAgentProblemRequest) (*empty.Empty, error)
	ReportAgentSignal   func(context.Context, *ReportAgentSignalRequest) (*empty.Empty, error)
	ReportAgentLogs     func(context.Context, *ReportAgentLogsRequest) (*empty.Empty, error)
	ParseConfig         func(context.Context, *ParseConfigRequest) (*ParseConfigResponse, error)
}

func (s *CirrusCIServiceService) initialCommands(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitialCommandsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.InitialCommands(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/org.cirruslabs.ci.services.cirruscigrpc.CirrusCIService/InitialCommands",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.InitialCommands(ctx, req.(*InitialCommandsRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *CirrusCIServiceService) reportSingleCommand(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportSingleCommandRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.ReportSingleCommand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/org.cirruslabs.ci.services.cirruscigrpc.CirrusCIService/ReportSingleCommand",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.ReportSingleCommand(ctx, req.(*ReportSingleCommandRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *CirrusCIServiceService) reportAnnotations(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportAnnotationsCommandRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.ReportAnnotations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/org.cirruslabs.ci.services.cirruscigrpc.CirrusCIService/ReportAnnotations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.ReportAnnotations(ctx, req.(*ReportAnnotationsCommandRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *CirrusCIServiceService) streamLogs(_ interface{}, stream grpc.ServerStream) error {
	return s.StreamLogs(&cirrusCIServiceStreamLogsServer{stream})
}
func (s *CirrusCIServiceService) saveLogs(_ interface{}, stream grpc.ServerStream) error {
	return s.SaveLogs(&cirrusCIServiceSaveLogsServer{stream})
}
func (s *CirrusCIServiceService) uploadCache(_ interface{}, stream grpc.ServerStream) error {
	return s.UploadCache(&cirrusCIServiceUploadCacheServer{stream})
}
func (s *CirrusCIServiceService) uploadArtifacts(_ interface{}, stream grpc.ServerStream) error {
	return s.UploadArtifacts(&cirrusCIServiceUploadArtifactsServer{stream})
}
func (s *CirrusCIServiceService) downloadCache(_ interface{}, stream grpc.ServerStream) error {
	m := new(DownloadCacheRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return s.DownloadCache(m, &cirrusCIServiceDownloadCacheServer{stream})
}
func (s *CirrusCIServiceService) cacheInfo(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CacheInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.CacheInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/org.cirruslabs.ci.services.cirruscigrpc.CirrusCIService/CacheInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.CacheInfo(ctx, req.(*CacheInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *CirrusCIServiceService) ping(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/org.cirruslabs.ci.services.cirruscigrpc.CirrusCIService/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.Ping(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *CirrusCIServiceService) heartbeat(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.Heartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/org.cirruslabs.ci.services.cirruscigrpc.CirrusCIService/Heartbeat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.Heartbeat(ctx, req.(*HeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *CirrusCIServiceService) reportStopHook(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportStopHookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.ReportStopHook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/org.cirruslabs.ci.services.cirruscigrpc.CirrusCIService/ReportStopHook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.ReportStopHook(ctx, req.(*ReportStopHookRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *CirrusCIServiceService) reportAgentError(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportAgentProblemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.ReportAgentError(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/org.cirruslabs.ci.services.cirruscigrpc.CirrusCIService/ReportAgentError",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.ReportAgentError(ctx, req.(*ReportAgentProblemRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *CirrusCIServiceService) reportAgentWarning(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportAgentProblemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.ReportAgentWarning(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/org.cirruslabs.ci.services.cirruscigrpc.CirrusCIService/ReportAgentWarning",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.ReportAgentWarning(ctx, req.(*ReportAgentProblemRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *CirrusCIServiceService) reportAgentSignal(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportAgentSignalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.ReportAgentSignal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/org.cirruslabs.ci.services.cirruscigrpc.CirrusCIService/ReportAgentSignal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.ReportAgentSignal(ctx, req.(*ReportAgentSignalRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *CirrusCIServiceService) reportAgentLogs(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportAgentLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.ReportAgentLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/org.cirruslabs.ci.services.cirruscigrpc.CirrusCIService/ReportAgentLogs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.ReportAgentLogs(ctx, req.(*ReportAgentLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *CirrusCIServiceService) parseConfig(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ParseConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.ParseConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/org.cirruslabs.ci.services.cirruscigrpc.CirrusCIService/ParseConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.ParseConfig(ctx, req.(*ParseConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

type CirrusCIService_StreamLogsServer interface {
	SendAndClose(*UploadLogsResponse) error
	Recv() (*LogEntry, error)
	grpc.ServerStream
}

type cirrusCIServiceStreamLogsServer struct {
	grpc.ServerStream
}

func (x *cirrusCIServiceStreamLogsServer) SendAndClose(m *UploadLogsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *cirrusCIServiceStreamLogsServer) Recv() (*LogEntry, error) {
	m := new(LogEntry)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

type CirrusCIService_SaveLogsServer interface {
	SendAndClose(*UploadLogsResponse) error
	Recv() (*LogEntry, error)
	grpc.ServerStream
}

type cirrusCIServiceSaveLogsServer struct {
	grpc.ServerStream
}

func (x *cirrusCIServiceSaveLogsServer) SendAndClose(m *UploadLogsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *cirrusCIServiceSaveLogsServer) Recv() (*LogEntry, error) {
	m := new(LogEntry)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

type CirrusCIService_UploadCacheServer interface {
	SendAndClose(*UploadCacheResponse) error
	Recv() (*CacheEntry, error)
	grpc.ServerStream
}

type cirrusCIServiceUploadCacheServer struct {
	grpc.ServerStream
}

func (x *cirrusCIServiceUploadCacheServer) SendAndClose(m *UploadCacheResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *cirrusCIServiceUploadCacheServer) Recv() (*CacheEntry, error) {
	m := new(CacheEntry)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

type CirrusCIService_UploadArtifactsServer interface {
	SendAndClose(*UploadArtifactsResponse) error
	Recv() (*ArtifactEntry, error)
	grpc.ServerStream
}

type cirrusCIServiceUploadArtifactsServer struct {
	grpc.ServerStream
}

func (x *cirrusCIServiceUploadArtifactsServer) SendAndClose(m *UploadArtifactsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *cirrusCIServiceUploadArtifactsServer) Recv() (*ArtifactEntry, error) {
	m := new(ArtifactEntry)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

type CirrusCIService_DownloadCacheServer interface {
	Send(*DataChunk) error
	grpc.ServerStream
}

type cirrusCIServiceDownloadCacheServer struct {
	grpc.ServerStream
}

func (x *cirrusCIServiceDownloadCacheServer) Send(m *DataChunk) error {
	return x.ServerStream.SendMsg(m)
}

// RegisterCirrusCIServiceService registers a service implementation with a gRPC server.
func RegisterCirrusCIServiceService(s grpc.ServiceRegistrar, srv *CirrusCIServiceService) {
	srvCopy := *srv
	if srvCopy.InitialCommands == nil {
		srvCopy.InitialCommands = func(context.Context, *InitialCommandsRequest) (*CommandsResponse, error) {
			return nil, status.Errorf(codes.Unimplemented, "method InitialCommands not implemented")
		}
	}
	if srvCopy.ReportSingleCommand == nil {
		srvCopy.ReportSingleCommand = func(context.Context, *ReportSingleCommandRequest) (*ReportSingleCommandResponse, error) {
			return nil, status.Errorf(codes.Unimplemented, "method ReportSingleCommand not implemented")
		}
	}
	if srvCopy.ReportAnnotations == nil {
		srvCopy.ReportAnnotations = func(context.Context, *ReportAnnotationsCommandRequest) (*empty.Empty, error) {
			return nil, status.Errorf(codes.Unimplemented, "method ReportAnnotations not implemented")
		}
	}
	if srvCopy.StreamLogs == nil {
		srvCopy.StreamLogs = func(CirrusCIService_StreamLogsServer) error {
			return status.Errorf(codes.Unimplemented, "method StreamLogs not implemented")
		}
	}
	if srvCopy.SaveLogs == nil {
		srvCopy.SaveLogs = func(CirrusCIService_SaveLogsServer) error {
			return status.Errorf(codes.Unimplemented, "method SaveLogs not implemented")
		}
	}
	if srvCopy.UploadCache == nil {
		srvCopy.UploadCache = func(CirrusCIService_UploadCacheServer) error {
			return status.Errorf(codes.Unimplemented, "method UploadCache not implemented")
		}
	}
	if srvCopy.UploadArtifacts == nil {
		srvCopy.UploadArtifacts = func(CirrusCIService_UploadArtifactsServer) error {
			return status.Errorf(codes.Unimplemented, "method UploadArtifacts not implemented")
		}
	}
	if srvCopy.DownloadCache == nil {
		srvCopy.DownloadCache = func(*DownloadCacheRequest, CirrusCIService_DownloadCacheServer) error {
			return status.Errorf(codes.Unimplemented, "method DownloadCache not implemented")
		}
	}
	if srvCopy.CacheInfo == nil {
		srvCopy.CacheInfo = func(context.Context, *CacheInfoRequest) (*CacheInfoResponse, error) {
			return nil, status.Errorf(codes.Unimplemented, "method CacheInfo not implemented")
		}
	}
	if srvCopy.Ping == nil {
		srvCopy.Ping = func(context.Context, *empty.Empty) (*empty.Empty, error) {
			return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
		}
	}
	if srvCopy.Heartbeat == nil {
		srvCopy.Heartbeat = func(context.Context, *HeartbeatRequest) (*HeartbeatResponse, error) {
			return nil, status.Errorf(codes.Unimplemented, "method Heartbeat not implemented")
		}
	}
	if srvCopy.ReportStopHook == nil {
		srvCopy.ReportStopHook = func(context.Context, *ReportStopHookRequest) (*empty.Empty, error) {
			return nil, status.Errorf(codes.Unimplemented, "method ReportStopHook not implemented")
		}
	}
	if srvCopy.ReportAgentError == nil {
		srvCopy.ReportAgentError = func(context.Context, *ReportAgentProblemRequest) (*empty.Empty, error) {
			return nil, status.Errorf(codes.Unimplemented, "method ReportAgentError not implemented")
		}
	}
	if srvCopy.ReportAgentWarning == nil {
		srvCopy.ReportAgentWarning = func(context.Context, *ReportAgentProblemRequest) (*empty.Empty, error) {
			return nil, status.Errorf(codes.Unimplemented, "method ReportAgentWarning not implemented")
		}
	}
	if srvCopy.ReportAgentSignal == nil {
		srvCopy.ReportAgentSignal = func(context.Context, *ReportAgentSignalRequest) (*empty.Empty, error) {
			return nil, status.Errorf(codes.Unimplemented, "method ReportAgentSignal not implemented")
		}
	}
	if srvCopy.ReportAgentLogs == nil {
		srvCopy.ReportAgentLogs = func(context.Context, *ReportAgentLogsRequest) (*empty.Empty, error) {
			return nil, status.Errorf(codes.Unimplemented, "method ReportAgentLogs not implemented")
		}
	}
	if srvCopy.ParseConfig == nil {
		srvCopy.ParseConfig = func(context.Context, *ParseConfigRequest) (*ParseConfigResponse, error) {
			return nil, status.Errorf(codes.Unimplemented, "method ParseConfig not implemented")
		}
	}
	sd := grpc.ServiceDesc{
		ServiceName: "org.cirruslabs.ci.services.cirruscigrpc.CirrusCIService",
		Methods: []grpc.MethodDesc{
			{
				MethodName: "InitialCommands",
				Handler:    srvCopy.initialCommands,
			},
			{
				MethodName: "ReportSingleCommand",
				Handler:    srvCopy.reportSingleCommand,
			},
			{
				MethodName: "ReportAnnotations",
				Handler:    srvCopy.reportAnnotations,
			},
			{
				MethodName: "CacheInfo",
				Handler:    srvCopy.cacheInfo,
			},
			{
				MethodName: "Ping",
				Handler:    srvCopy.ping,
			},
			{
				MethodName: "Heartbeat",
				Handler:    srvCopy.heartbeat,
			},
			{
				MethodName: "ReportStopHook",
				Handler:    srvCopy.reportStopHook,
			},
			{
				MethodName: "ReportAgentError",
				Handler:    srvCopy.reportAgentError,
			},
			{
				MethodName: "ReportAgentWarning",
				Handler:    srvCopy.reportAgentWarning,
			},
			{
				MethodName: "ReportAgentSignal",
				Handler:    srvCopy.reportAgentSignal,
			},
			{
				MethodName: "ReportAgentLogs",
				Handler:    srvCopy.reportAgentLogs,
			},
			{
				MethodName: "ParseConfig",
				Handler:    srvCopy.parseConfig,
			},
		},
		Streams: []grpc.StreamDesc{
			{
				StreamName:    "StreamLogs",
				Handler:       srvCopy.streamLogs,
				ClientStreams: true,
			},
			{
				StreamName:    "SaveLogs",
				Handler:       srvCopy.saveLogs,
				ClientStreams: true,
			},
			{
				StreamName:    "UploadCache",
				Handler:       srvCopy.uploadCache,
				ClientStreams: true,
			},
			{
				StreamName:    "UploadArtifacts",
				Handler:       srvCopy.uploadArtifacts,
				ClientStreams: true,
			},
			{
				StreamName:    "DownloadCache",
				Handler:       srvCopy.downloadCache,
				ServerStreams: true,
			},
		},
		Metadata: "cirrus_ci_service.proto",
	}

	s.RegisterService(&sd, nil)
}
